<!doctype html><html lang=en><head><script>location.host!=new URL("https://yangyangli.top/").host&&(location.href="https://yangyangli.top/")</script><meta name=viewport content="width=device-width"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=7"><link rel=icon href=/favicon.png><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=icon href=/logo.svg type=image/svg+xml><title>Nei Saitou Neighbor Joining &ndash;
Yangyang Li's Geek Logs</title><link href=/symbols-nerd-font/symbols-nerd-font.css rel=stylesheet integrity="sha512-lydow8GLOLlYNOtHlksNCmGWWCBsbIEtikXpHzfWqx78HLlyQZHOzyLwPpKol4Th6aCwLUXOfODVYgwrd3nwKQ=="><link href=/jetbrains-mono/jetbrains-mono.css rel=stylesheet integrity="sha512-tJxlgL6v1Y7kFf+qB8SloaAMKnOAw6WouknxXtIjkBux9Y/9aX81EUWOJO8c/3l98DmjG8brr4to7zaez606Fg=="><link rel=stylesheet href=https://latest.cactus.chat/style.css type=text/css><link type=text/css rel=stylesheet href=https://yangyangli.top/css/styles.f13b26608bee58be5a71a28a962268940cf92222048d1ee76e364329803107c0986170f96b89f0c24d03be85521b7514af6163a713f29d2e7b450c8933e9edfb.css integrity="sha512-8TsmYIvuWL5acaKKliJolAz5IiIEjR7nbjZDKYAxB8CYYXD5a4nwwk0DvoVSG3UUr2FjpxPynS57RQyJM+nt+w=="><meta name=author content="Yangyang Li"><meta name=keywords content="Bioinformatics"><meta name=description content="one of my homework that requires me to implement Nei-Saitou Neighbor Joining algorithm to construct phylogenetic tree, as well as evaluating the bootstrap cconfidence"><meta property="og:site_name" content="Yangyang Li's Geek Logs"><meta property="og:title" content="Nei Saitou Neighbor Joining"><meta property="og:type" content="article"><meta property="article:author" content="Yangyang Li"><meta property="article:published_time" content="2021-04-03T11:15:00Z+0800"><meta property="article:tag" content="Bioinformatics"><meta property="og:url" content="https://yangyangli.top/posts/008-nei-saitou-neighbor-joining/"><meta property="og:image" content="https://yangyangli.top/icon512.png"><meta property="og:description" content="one of my homework that requires me to implement Nei-Saitou Neighbor Joining algorithm to construct phylogenetic tree, as well as evaluating the bootstrap cconfidence"><meta name=twitter:card content="summary_large_image"><meta property="twitter:domain" content="yangyangli.to"><meta property="twitter:url" content="https://yangyangli.top/posts/008-nei-saitou-neighbor-joining/"><meta name=twitter:title content="Nei Saitou Neighbor Joining"><meta name=twitter:image content="https://yangyangli.top/icon512.png"><meta name=twitter:description content="one of my homework that requires me to implement Nei-Saitou Neighbor Joining algorithm to construct phylogenetic tree, as well as evaluating the bootstrap cconfidence"><link rel=manifest href=/manifest/index.json></head><body><div id=baseContainer><header><div class=titleAndSearchContainer><div id=titleContainer><a class=unstyledLink href=/><img src=/logo.svg alt=Logo></a><div class=rightOfLogo><div class=titleAndHamburger><h1><a class=unstyledLink href=/>Yangyang Li's Geek Logs</a></h1><label id=hamburger-menu for=main-nav-toggler>&#xf85b;</label></div><div id=wide_nav><nav><input type=checkbox id=main-nav-toggler><ul id=main-nav><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=https://yangyangli.top/pages/about/>About</a></li><li><a href=/resume.pdf>CV</a></li><li><a href=/tags>Tags</a></li></ul></nav></div></div></div><div class=search><input id=searchbar type=text placeholder=Search>
<a class=nerdlink onclick=newSearch()>&#xf002;</a></div><script>function newSearch(){let e=searchbar.value.trim();if(!e)return;location.href=`/search?q=${e}`}searchbar.onkeyup=e=>{e.keyCode==13&&newSearch()}</script></div><div id=links><a rel=noreferrer target=_blank class=nerdlink href=/index.xml>&#xf09e;
<span>RSS</span></a>
<a rel=noreferrer target=_blank class=nerdlink href=https://github.com/cauliyang>&#xf09b;
<span>GitHub</span></a>
<a rel=noreferrer target=_blank class=nerdlink href=https://twitter.com/yangyangliz5>&#xf099;
<span>Twitter</span></a>
<a rel=noreferrer target=_blank class=nerdlink href=mailto:yangyang.li@norwestern.edu>&#xf6ed;
<span>Email</span></a>
<a rel=noreferrer target=_blank class=nerdlink href="https://scholar.google.com/citations?user=ByWsRVMAAAAJ&hl=en"><svg class="pseudofont" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 27 27"><defs><clipPath id="id1"><path d="M3.386719 3H27.339844V28H3.386719zm0 0" clip-rule="nonzero" fill="#fff"/></clipPath></defs><g clip-path="url(#id1)"><path fill="#fff" d="M14.660156 3.25 3.386719 10.308594H11.125C11.097656 10.417969 11.050781 10.515625 11.027344 10.625 10.960938 10.964844 10.910156 11.34375 10.910156 11.734375c0 5.039063 5.144532 4.472656 5.144532 4.472656v1.285157C16.054688 18.011719 16.734375 17.832031 16.816406 18.890625 16.476562 18.890625 9.691406 18.695312 9.691406 23.277344c0 4.605468 5.988282 4.378906 5.988282 4.378906S22.59375 27.964844 22.59375 22.273438C22.597656 18.871094 18.636719 17.765625 18.636719 16.398438c0-1.382813 2.984375-1.789063 2.984375-5.023438C21.621094 9.960938 21.523438 8.953125 20.890625 8.238281 20.84375 8.1875 20.808594 8.152344 20.761719 8.121094 20.75 8.109375 20.738281 8.101562 20.726562 8.09375H20.898438l2.917968-2.191406V8.898438C23.816406 8.953125 23.820312 9.007812 23.832031 9.0625 23.609375 9.1875 23.429688 9.363281 23.300781 9.585938 23.171875 9.808594 23.109375 10.050781 23.113281 10.308594v1.414062C23.109375 11.910156 23.144531 12.09375 23.214844 12.269531 23.285156 12.445312 23.386719 12.597656 23.515625 12.734375 23.648438 12.867188 23.804688 12.972656 23.976562 13.042969 24.152344 13.117188 24.332031 13.152344 24.519531 13.152344 24.710938 13.152344 24.890625 13.117188 25.066406 13.042969 25.238281 12.972656 25.390625 12.867188 25.523438 12.734375 25.65625 12.597656 25.757812 12.445312 25.828125 12.269531 25.898438 12.09375 25.933594 11.910156 25.929688 11.722656V10.308594C25.933594 10.050781 25.871094 9.808594 25.742188 9.585938 25.613281 9.363281 25.433594 9.1875 25.207031 9.0625 25.21875 9.007812 25.226562 8.953125 25.226562 8.898438V4.839844L27.339844 3.25zM15.632812 7.5625C16.039062 7.542969 16.445312 7.640625 16.835938 7.863281 17.125 8.007812 17.402344 8.21875 17.644531 8.480469 18.148438 8.984375 18.570312 9.714844 18.796875 10.578125 19.332031 12.625 18.636719 14.597656 17.191406 14.96875 15.765625 15.375 14.171875 14.039062 13.621094 12.007812 13.378906 11.015625 13.410156 10.054688 13.6875 9.292969 13.691406 9.28125 13.695312 9.273438 13.699219 9.265625 13.703125 9.261719 13.710938 9.257812 13.714844 9.253906 13.792969 8.953125 13.921875 8.679688 14.082031 8.457031 14.371094 8.035156 14.753906 7.746094 15.226562 7.617188 15.363281 7.585938 15.496094 7.566406 15.632812 7.5625zM16.183594 19.75C18.566406 19.570312 20.597656 20.886719 20.746094 22.675781 20.84375 24.449219 19.007812 26.027344 16.605469 26.1875 14.222656 26.351562 12.160156 25.050781 12.046875 23.277344 11.933594 21.492188 13.78125 19.929688 16.183594 19.75zm0 0" fill-opacity="1" fill-rule="nonzero"/></g></svg><span>Google Scholar</span></a></div></header><div id=contentContainer><div id=content><main><article class="card single"><h1>Nei Saitou Neighbor Joining</h1><p class=date><span title=Date></span>
2021-04-03</p><div class=articleToc><nav id=TableOfContents><ul><li><ul><li><a href=#1-background>1. Background</a></li><li><a href=#2-neighbor-joining-algorithm>2. Neighbor Joining Algorithm</a></li><li><a href=#3-implementation>3. Implementation</a></li></ul></li></ul></nav><hr></div><div><h2 id=1-background>1. Background</h2><p>Before diving into code, the description of NJ algorithm can be found in <img src=https://cdn.jsdelivr.net/gh/cauliyang/blog-image@main//img/1605172209524.png alt="This Link">, where first column indicates parent node, and second column is its children node, the last column is the value of edge.</p><h2 id=2-neighbor-joining-algorithm>2. Neighbor Joining Algorithm</h2><p>The Neighbor-joining Algorithm Given a distance matrix d compute an uprooted tree topology complete with edge lengths that tries to preserve the additive property: $d_{i,m} + d_{j,m} − d_{i,j} = 2d_{k,m}$ where $k$ is the k-th node on both routes from $i$ and $j$ to $m$.</p><ol><li>Let the set of clusters be called $L$ and initially $i → C_i; ∀i$ that is $| C_i | = 1$ and $L = C_1 , C_2 , . . . C_N$.</li><li>$d_{i,j}$ is the distance from the initial distance matrix.</li><li>Compute “normalized distance matrix” $D_{i,j}$ for all $i, j$ such that
$$D_{i,j} = d_{i,j} − (r_i + r_j ) \ where\ r_i = \frac{1}{|L|-2} \sum_{z \in L} d_{i,z}$$
This subtracts the average distance to all other nodes than the pair involved. <strong>Note: this is not where we use the distance identity.</strong></li><li>Use normalized distance to ﬁnd $(i, j) = argmin D_{i,j}; C_i,C_j \in L$</li><li>Merge $C_i ∪ C_j → C_k$ where $k$ is a new cluster number.</li><li>Mark old clusters as used so that effectively: $L ← L − C_i − C_j$</li><li>Compute a new normalized distance matrix including the new cluster $k$ and excluding $i, j$.
$$d_{k,z} = d_{z,k} = (d_{i,z} + d_{j,,z} − d_{i,j} ) for all z ∈ L 2$$
This uses the additivity of the distances to compute the distance to the new cluster from each other node.</li><li>Compute the length of the edges from $k$ to $i$ and $j$. Even though $C_k$has assumed the role of both $C_i$ and $C_j$ you still need the edge length to $i$ and $j$ from $k$ in order to “draw” the tree.
$$edge_{i,k} = (d_{i,j} + r_i − r_j)$$
$$edge_{j,k} = (d_{i,j} + r_j − r_i)$$</li><li>Deﬁne height $h_k = d_{i,j} /2$ where $h_k$ is the height of node that is the ancestor to all in $C_k$. When drawing the tree $h_k$ is the height above the baseline (where all the leaves are).</li><li>$L ← L ∪ C_k$</li><li>While there is more than two clusters left go to step 3</li><li>Finally, join the remaining two clusters with:
$$edge_{j,k} = d_{i,j} $$</li></ol><p><strong>Implementation Notes Consider this part of the computation:</strong>
$$D_{i,j} = d_{i,j} − (r_i + r_j ) \ where \ r_i = \frac{1}{|L|-2} \sum_{z \in L}d_{i,z}$$
The values of r<em>z can be computed once each time we want to compute matrix $D$. This saves a vast amount of time. Furthermore, since $D</em>{i,j}$ is only used to ﬁnd the argmin of $D_{i,j}$ we actually don’t have to save array $D$; we only need to ﬁnd the argmin of it. So ﬁrst compute all the r and then combine the argmin step with the computation of $D_{i,j}$</p><h2 id=3-implementation>3. Implementation</h2><p>I write code contained comments, and it is about 1000 lines that consumes me two whole days. Now let me show my code with rich comments. If you have any questions or recommendation, I am very glad to communicate with you! Please feel free to reach me.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># -*- coding: UTF-8 -*-</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Time 20201109</span>
</span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>This code integrate bootstrap, getting edge_file and tree_file
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>USAGE: python -i fa_file -d out_distance_matrix -e out_edge -t out_tree -b number_bootstrap
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># import needed library</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> argparse
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> logging
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> random
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> time
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> collections <span style=color:#ff79c6>import</span> defaultdict, namedtuple
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> pandas <span style=color:#ff79c6>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Timer</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[construct  Timer to show working time of tasks]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> __init__(self, func<span style=color:#ff79c6>=</span>time<span style=color:#ff79c6>.</span>perf_counter):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[init values]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            func : Defaults to time.perf_counter.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>elapsed <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>_func <span style=color:#ff79c6>=</span> func
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>start</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[start a task]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Raises:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            RuntimeError:[if task has started then raise error]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>raise</span> RuntimeError(<span style=color:#f1fa8c>&#34;Already started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>_func()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>stop</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[end a task]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Raises:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            RuntimeError[if task has not started then raise error]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>raise</span> RuntimeError(<span style=color:#f1fa8c>&#34;Not started&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        end <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>_func()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>elapsed <span style=color:#ff79c6>+=</span> end <span style=color:#ff79c6>-</span> self<span style=color:#ff79c6>.</span>_start
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>reset</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[reset the working time]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>elapsed <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>running</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[check if task is running]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            bool
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>_start <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> __enter__(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[function used to address &#39;with text&#39;]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> __exit__(self, <span style=color:#ff79c6>*</span>args):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[function used to address &#39;with text&#39;]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>stop()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TreeNode</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[class of tree node]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> __init__(self, key<span style=color:#ff79c6>=</span><span style=color:#ff79c6>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[init values of tree node]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            key ([str, float], optional): [node_label, edge]. Defaults to None.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            self.index: node_index
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>left, self<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>, <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>key <span style=color:#ff79c6>=</span> key
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>parent, self<span style=color:#ff79c6>.</span>index <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>, <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#ff79c6>.</span>LIST <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>insert_left_children</span>(self, left_object):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[insert left children]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            left_object ([str, float]): [node_label, edge]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># create a new node</span>
</span></span><span style=display:flex><span>        temp <span style=color:#ff79c6>=</span> TreeNode(left_object)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># if left children exist</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>left:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            temp<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>left
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>=</span> temp
</span></span><span style=display:flex><span>        <span style=color:#6272a4># if left children does not exist</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>=</span> temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>insert_right_children</span>(self, right_object):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[insert right children]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            right_object ([str, float]): [node_label, edge]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># create a new node</span>
</span></span><span style=display:flex><span>        temp <span style=color:#ff79c6>=</span> TreeNode(right_object)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># if right children exist</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>right:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            temp<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> self<span style=color:#ff79c6>.</span>right
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> temp
</span></span><span style=display:flex><span>        <span style=color:#6272a4># if right children does not exist</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> temp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>isRoot</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[check if the node is Root node]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            [bool]: [if node is Root return True]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        handle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;root&#34;</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            handle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> handle
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>isLeaf</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;check if the node is Leaf node
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            bool: if the node is Leaf return True
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        handle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> self<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> self<span style=color:#ff79c6>.</span>right:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            handle <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> handle
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>catch_leaf</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;show the partition list of leafs below the node, and mainly used to debug
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            list: a list contained all leaf below the node
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        LIST <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># check if the node is leaf</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>isLeaf():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            LIST<span style=color:#ff79c6>.</span>append(self<span style=color:#ff79c6>.</span>index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>left:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            LIST<span style=color:#ff79c6>.</span>extend(self<span style=color:#ff79c6>.</span>left<span style=color:#ff79c6>.</span>catch_leaf())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>right:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            LIST<span style=color:#ff79c6>.</span>extend(self<span style=color:#ff79c6>.</span>right<span style=color:#ff79c6>.</span>catch_leaf())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> LIST
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>postorder</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[tree traversal with postorder, and mainly used to debug]&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>left:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>left<span style=color:#ff79c6>.</span>postorder()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> self<span style=color:#ff79c6>.</span>right:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            self<span style=color:#ff79c6>.</span>right<span style=color:#ff79c6>.</span>postorder()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(self<span style=color:#ff79c6>.</span>key)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>get_parser</span>() <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[function used to parse parameters from command line and set log]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        [dict]: [return a dict stored parameters]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># set logging</span>
</span></span><span style=display:flex><span>    logging<span style=color:#ff79c6>.</span>basicConfig(
</span></span><span style=display:flex><span>        level<span style=color:#ff79c6>=</span>logging<span style=color:#ff79c6>.</span>DEBUG, <span style=color:#8be9fd;font-style:italic>format</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>%(levelname)s</span><span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>%(asctime)s</span><span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>%(message)s</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># set parser</span>
</span></span><span style=display:flex><span>    parser <span style=color:#ff79c6>=</span> argparse<span style=color:#ff79c6>.</span>ArgumentParser(
</span></span><span style=display:flex><span>        prog<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;PROG&#34;</span>,
</span></span><span style=display:flex><span>        description<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;Program designed to condcut NJ &#34;</span>,
</span></span><span style=display:flex><span>        formatter_class<span style=color:#ff79c6>=</span>argparse<span style=color:#ff79c6>.</span>MetavarTypeHelpFormatter,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add parameter for input of fa file</span>
</span></span><span style=display:flex><span>    parser<span style=color:#ff79c6>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;-i&#34;</span>, <span style=color:#f1fa8c>&#34;--input&#34;</span>, help<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;The input file (fasta format)&#34;</span>, required<span style=color:#ff79c6>=</span><span style=color:#ff79c6>True</span>, <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>str</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add parameter for output of edge file</span>
</span></span><span style=display:flex><span>    parser<span style=color:#ff79c6>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;-e&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;--edge&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;The output file of edges matrix. Default: edges.txt&#34;</span>,
</span></span><span style=display:flex><span>        default<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;edges.txt&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>str</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add parameter for output of tree file</span>
</span></span><span style=display:flex><span>    parser<span style=color:#ff79c6>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;-t&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;--tree&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;The output file of newick tree. Default: tree.txt&#34;</span>,
</span></span><span style=display:flex><span>        default<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;tree.txt&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>str</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add parameter for output of distance matrix</span>
</span></span><span style=display:flex><span>    parser<span style=color:#ff79c6>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;-d&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;--distance&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;The output file of distance matrix. Default: genetic_distance.txt&#34;</span>,
</span></span><span style=display:flex><span>        default<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;genetic_distance.txt&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>str</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add parameter for number of bootstrap; Default: not conduct bootstrap</span>
</span></span><span style=display:flex><span>    parser<span style=color:#ff79c6>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;-b&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;--bootstrap&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;The number of bootstrap. Result will be stored in &#39;bootstrap.txt&#39;&#34;</span>,
</span></span><span style=display:flex><span>        default<span style=color:#ff79c6>=</span><span style=color:#ff79c6>None</span>,
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>int</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get parameters</span>
</span></span><span style=display:flex><span>    args <span style=color:#ff79c6>=</span> parser<span style=color:#ff79c6>.</span>parse_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> args
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># CELL FOR GETTING GENETIC DISTANCE MATRIX</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>read_input</span>(<span style=color:#8be9fd;font-style:italic>input</span>: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[read input of fa file and return a dict whose value is nametuple stored information]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        input (str): [fasta file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        dict: [seq_label: (seq,index )]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#  create namedtuple to store information</span>
</span></span><span style=display:flex><span>    seqs, seq <span style=color:#ff79c6>=</span> {}, namedtuple(<span style=color:#f1fa8c>&#34;info&#34;</span>, [<span style=color:#f1fa8c>&#34;seq&#34;</span>, <span style=color:#f1fa8c>&#34;index&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># open file as a list</span>
</span></span><span style=display:flex><span>    content <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(<span style=color:#8be9fd;font-style:italic>input</span>)<span style=color:#ff79c6>.</span>readlines()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init index of sequence</span>
</span></span><span style=display:flex><span>    read_index <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># read seq into the dict</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> index, line <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>enumerate</span>(content):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># check header</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> line<span style=color:#ff79c6>.</span>startswith(<span style=color:#f1fa8c>&#34;&gt;&#34;</span>):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            seqs[line<span style=color:#ff79c6>.</span>strip(<span style=color:#f1fa8c>&#34;&gt;</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)] <span style=color:#ff79c6>=</span> seq(content[index <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>]<span style=color:#ff79c6>.</span>strip(), read_index)
</span></span><span style=display:flex><span>            read_index <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> seqs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>genetic_distance</span>(seq1: <span style=color:#8be9fd;font-style:italic>str</span>, seq2: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>float</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[calculate genetic distance of seq1 and seqw]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seq1 (str): [sequences of seq1]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seq2 (str): [sequences of seq2]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        float: [genetic distance]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get length of sequences</span>
</span></span><span style=display:flex><span>    length <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>len</span>(seq1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init mismatch</span>
</span></span><span style=display:flex><span>    mismatch <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># begin to calculate</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> s1, s2 <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>zip</span>(seq1, seq2):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> s1 <span style=color:#ff79c6>!=</span> s2:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            mismatch <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> mismatch <span style=color:#ff79c6>/</span> length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fetch_distance</span>(seq1_index: <span style=color:#8be9fd;font-style:italic>str</span>, seq2_index: <span style=color:#8be9fd;font-style:italic>str</span>, matrix: <span style=color:#8be9fd;font-style:italic>dict</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>float</span> <span style=color:#ff79c6>or</span> <span style=color:#ff79c6>None</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[fetch distance from distance matrix in case comupute pair distance repeatedly]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seq1_index (str): [seq1 label]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seq2_index (str): [seq2 label]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        matrix (dict): [store distances that is calculated]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        float or None: [if distance has calculated return value otherwise None]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init value</span>
</span></span><span style=display:flex><span>    distance <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># check if the distance is already calculated</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (seq1_index, seq2_index) <span style=color:#ff79c6>in</span> matrix:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        distance <span style=color:#ff79c6>=</span> matrix[(seq1_index, seq2_index)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>elif</span> (seq2_index, seq1_index) <span style=color:#ff79c6>in</span> matrix:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        distance <span style=color:#ff79c6>=</span> matrix[(seq2_index, seq1_index)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> distance
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>get_distance_matrix</span>(seqs: <span style=color:#8be9fd;font-style:italic>dict</span>, out: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[write distance matrix to file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seqs (dict): [store information of seqs like {seq_label: (seq:, index:)}]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        out (str): [the name of genetic distance file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        dict: [{(seq1_label,seq2_label):genetic_distance}]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># open new file</span>
</span></span><span style=display:flex><span>    out_put <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(out, <span style=color:#f1fa8c>&#34;w&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init dict</span>
</span></span><span style=display:flex><span>    distance_map <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># write header</span>
</span></span><span style=display:flex><span>    header <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>&#34;</span><span style=color:#ff79c6>.</span>join(seqs<span style=color:#ff79c6>.</span>keys())
</span></span><span style=display:flex><span>    out_put<span style=color:#ff79c6>.</span>write(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>header<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># begin to calculate distance and write to file</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> seq1_label, seq1_info <span style=color:#ff79c6>in</span> seqs<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>        <span style=color:#6272a4># init list to store distance of every line</span>
</span></span><span style=display:flex><span>        line <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> seq2_label, seq2_info <span style=color:#ff79c6>in</span> seqs<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#6272a4># check if the distance is already computed</span>
</span></span><span style=display:flex><span>            distance <span style=color:#ff79c6>=</span> fetch_distance(seq1_label, seq2_label, distance_map)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> distance:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># if not exist then calculate it and store</span>
</span></span><span style=display:flex><span>                distance <span style=color:#ff79c6>=</span> genetic_distance(seq1_info<span style=color:#ff79c6>.</span>seq, seq2_info<span style=color:#ff79c6>.</span>seq)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                distance_map[(seq1_label, seq2_label)] <span style=color:#ff79c6>=</span> distance
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            line<span style=color:#ff79c6>.</span>append(distance)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># write every line</span>
</span></span><span style=display:flex><span>        line <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>&#34;</span><span style=color:#ff79c6>.</span>join([<span style=color:#8be9fd;font-style:italic>str</span>(element) <span style=color:#ff79c6>for</span> element <span style=color:#ff79c6>in</span> line])
</span></span><span style=display:flex><span>        out_put<span style=color:#ff79c6>.</span>write(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>seq1_label<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>line<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    out_put<span style=color:#ff79c6>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> distance_map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#                            NJ ALGORITHM</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>cacl_sum_distance</span>(taxa: <span style=color:#8be9fd;font-style:italic>str</span>, leaf_set: <span style=color:#8be9fd;font-style:italic>set</span>, distance_matrix: <span style=color:#8be9fd;font-style:italic>dict</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>float</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[calculate sum distance of node away from other nodes]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        taxa ([str]): [label for one node]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        leaf_set ([set]): [a set store current nodes needed to be merged]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        distance_matrix ([dict]): [{(seq1_label,seq2_label):genetic_distance}]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        [float]: [sum distance of node away from others]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init value</span>
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate sum distance</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> other_taxa <span style=color:#ff79c6>in</span> leaf_set <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>set</span>([taxa]):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># fectch genetic distance</span>
</span></span><span style=display:flex><span>        result <span style=color:#ff79c6>+=</span> fetch_distance(taxa, other_taxa, distance_matrix)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>find_qmin</span>(leaf_set: <span style=color:#8be9fd;font-style:italic>set</span>, distance_matrix: <span style=color:#8be9fd;font-style:italic>dict</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[ calculate min q_value and get information]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        leaf_set ([set]): [current nodes needed to be merged]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        distance_matrix ([dict]): [dict stored genetic distance of current nodes]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        [dict]:  [value, combination,taxa1_sum, taxa2_sum]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init dict</span>
</span></span><span style=display:flex><span>    qmin <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;combination&#34;</span>: <span style=color:#ff79c6>None</span>,  <span style=color:#6272a4># combination of node for merging</span>
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;q_value&#34;</span>: <span style=color:#ff79c6>None</span>,  <span style=color:#6272a4># min Q value</span>
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;taxa1_sum&#34;</span>: <span style=color:#ff79c6>None</span>,  <span style=color:#6272a4># sum distance of node away from others</span>
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;taxa2_sum&#34;</span>: <span style=color:#ff79c6>None</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate  Q value every combinatin of nodes</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> combination, distance <span style=color:#ff79c6>in</span> distance_matrix<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        taxa1, taxa2 <span style=color:#ff79c6>=</span> combination
</span></span><span style=display:flex><span>        <span style=color:#6272a4># calculate sum distance of node away from others</span>
</span></span><span style=display:flex><span>        taxa1_sum, taxa2_sum <span style=color:#ff79c6>=</span> cacl_sum_distance(
</span></span><span style=display:flex><span>            taxa1, leaf_set, distance_matrix
</span></span><span style=display:flex><span>        ), cacl_sum_distance(taxa2, leaf_set, distance_matrix)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># get Q value</span>
</span></span><span style=display:flex><span>        value <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd;font-style:italic>len</span>(leaf_set) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>*</span> distance <span style=color:#ff79c6>-</span> taxa1_sum <span style=color:#ff79c6>-</span> taxa2_sum
</span></span><span style=display:flex><span>        <span style=color:#6272a4># compare Q value</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> qmin[<span style=color:#f1fa8c>&#34;q_value&#34;</span>]:
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if Q value does not exist then store related information</span>
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                qmin[<span style=color:#f1fa8c>&#34;q_value&#34;</span>],
</span></span><span style=display:flex><span>                qmin[<span style=color:#f1fa8c>&#34;combination&#34;</span>],
</span></span><span style=display:flex><span>                qmin[<span style=color:#f1fa8c>&#34;taxa1_sum&#34;</span>],
</span></span><span style=display:flex><span>                qmin[<span style=color:#f1fa8c>&#34;taxa2_sum&#34;</span>],
</span></span><span style=display:flex><span>            ) <span style=color:#ff79c6>=</span> (value, combination, taxa1_sum, taxa2_sum)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># if Q value exist then compare to choose minimum value</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> value <span style=color:#ff79c6>&lt;</span> qmin[<span style=color:#f1fa8c>&#34;q_value&#34;</span>]:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                (
</span></span><span style=display:flex><span>                    qmin[<span style=color:#f1fa8c>&#34;q_value&#34;</span>],
</span></span><span style=display:flex><span>                    qmin[<span style=color:#f1fa8c>&#34;combination&#34;</span>],
</span></span><span style=display:flex><span>                    qmin[<span style=color:#f1fa8c>&#34;taxa1_sum&#34;</span>],
</span></span><span style=display:flex><span>                    qmin[<span style=color:#f1fa8c>&#34;taxa2_sum&#34;</span>],
</span></span><span style=display:flex><span>                ) <span style=color:#ff79c6>=</span> (value, combination, taxa1_sum, taxa2_sum)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> qmin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>help_nj</span>(leaf_set: <span style=color:#8be9fd;font-style:italic>set</span>, distance_matrix: <span style=color:#8be9fd;font-style:italic>dict</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[helper function to conduct neighbor joining]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        leaf_set ([set]): [current nodes needed to be merged]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        distance_matrix ([dict]): [store pair distance of current nodes]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        TREEDICT: a dict stored node that has been merged in binary tree format
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        final_leaf_set: final twos node after finishing NJ
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        final_matrix:  genetic distances of final two nodes
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init dict to store nodes that has been merged in format of Binary Tree</span>
</span></span><span style=display:flex><span>    TREEDICT <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>neighbor_joining</span>(leaf_set: <span style=color:#8be9fd;font-style:italic>set</span>, distance_matrix: <span style=color:#8be9fd;font-style:italic>dict</span>):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;[implementation of neighbors joining]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            leaf_set ([set]): [current nodes needed to be merged]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            distance_matrix ([dict]): [store genetic distance of current nodes]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># get nonlocal value</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>nonlocal</span> TREEDICT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># the rule to end the recursion</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(leaf_set) <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>3</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> (leaf_set, distance_matrix)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># enter recursion</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#6272a4># find min Q value</span>
</span></span><span style=display:flex><span>            qmin_info <span style=color:#ff79c6>=</span> find_qmin(leaf_set, distance_matrix)
</span></span><span style=display:flex><span>            <span style=color:#6272a4># get nodes needed to be merged</span>
</span></span><span style=display:flex><span>            taxa1, taxa2 <span style=color:#ff79c6>=</span> qmin_info[<span style=color:#f1fa8c>&#34;combination&#34;</span>]
</span></span><span style=display:flex><span>            <span style=color:#6272a4># edge from taxa1 to new node</span>
</span></span><span style=display:flex><span>            edge_taxa1_node <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0.5</span> <span style=color:#ff79c6>*</span> distance_matrix[qmin_info[<span style=color:#f1fa8c>&#34;combination&#34;</span>]] <span style=color:#ff79c6>+</span> (
</span></span><span style=display:flex><span>                qmin_info[<span style=color:#f1fa8c>&#34;taxa1_sum&#34;</span>] <span style=color:#ff79c6>-</span> qmin_info[<span style=color:#f1fa8c>&#34;taxa2_sum&#34;</span>]
</span></span><span style=display:flex><span>            ) <span style=color:#ff79c6>/</span> (<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>*</span> (<span style=color:#8be9fd;font-style:italic>len</span>(leaf_set) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>))
</span></span><span style=display:flex><span>            <span style=color:#6272a4># edge from taxa1 to new node</span>
</span></span><span style=display:flex><span>            edge_taxa2_node <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>                distance_matrix[qmin_info[<span style=color:#f1fa8c>&#34;combination&#34;</span>]] <span style=color:#ff79c6>-</span> edge_taxa1_node
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># init dict to update genetic matrix</span>
</span></span><span style=display:flex><span>            matrix <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>            <span style=color:#6272a4># create label for new node</span>
</span></span><span style=display:flex><span>            new_node <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>taxa1<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>_</span><span style=color:#f1fa8c>{</span>taxa2<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># calculate distance from new node to other nodes</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> node <span style=color:#ff79c6>in</span> leaf_set <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>set</span>(qmin_info[<span style=color:#f1fa8c>&#34;combination&#34;</span>]):
</span></span><span style=display:flex><span>                <span style=color:#6272a4># store in new genetic matrix with information of old genetic matrix</span>
</span></span><span style=display:flex><span>                matrix[(new_node, node)] <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>                    fetch_distance(taxa1, node, distance_matrix)
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>+</span> fetch_distance(taxa2, node, distance_matrix)
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>-</span> distance_matrix[(taxa1, taxa2)]
</span></span><span style=display:flex><span>                ) <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>0.5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># store genetic distances of other nodes in new genetic matrix</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> combination, distance <span style=color:#ff79c6>in</span> distance_matrix<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (taxa1 <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>in</span> combination) <span style=color:#ff79c6>and</span> (taxa2 <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>in</span> combination):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    matrix[combination] <span style=color:#ff79c6>=</span> distance
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># store phylogenetic nodes that has been merged in Binary Tree format</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># create a tree node that linked two merged nodes in Binary Tree</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if one of merged nodes has been in Binary Tree then add edges</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># taxa1 is always regarded as left children</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> taxa1 <span style=color:#ff79c6>in</span> TREEDICT:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> TREEDICT<span style=color:#ff79c6>.</span>pop(taxa1)
</span></span><span style=display:flex><span>                left<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> edge_taxa1_node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if one of merged nodes is not stored in Binary Tree</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># create a Tree node and store its label and edge</span>
</span></span><span style=display:flex><span>                left <span style=color:#ff79c6>=</span> TreeNode([taxa1, edge_taxa1_node])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># taxa2 is same with taxa1</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># taxa2 is always regarded as right children</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> taxa2 <span style=color:#ff79c6>in</span> TREEDICT:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> TREEDICT<span style=color:#ff79c6>.</span>pop(taxa2)
</span></span><span style=display:flex><span>                right<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> edge_taxa2_node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                right <span style=color:#ff79c6>=</span> TreeNode([taxa2, edge_taxa2_node])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># create a new_node linked two merged nodes in Binary Tree</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># the new_node has no edge</span>
</span></span><span style=display:flex><span>            internal_node <span style=color:#ff79c6>=</span> TreeNode([new_node, <span style=color:#ff79c6>None</span>])
</span></span><span style=display:flex><span>            <span style=color:#6272a4># add paraent information for two merged nodes</span>
</span></span><span style=display:flex><span>            left<span style=color:#ff79c6>.</span>parent, right<span style=color:#ff79c6>.</span>parent <span style=color:#ff79c6>=</span> internal_node, internal_node
</span></span><span style=display:flex><span>            <span style=color:#6272a4># link two merged nodes as children in Binary Tree</span>
</span></span><span style=display:flex><span>            internal_node<span style=color:#ff79c6>.</span>left, internal_node<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> left, right
</span></span><span style=display:flex><span>            <span style=color:#6272a4># add new node to dict</span>
</span></span><span style=display:flex><span>            TREEDICT[new_node] <span style=color:#ff79c6>=</span> internal_node
</span></span><span style=display:flex><span>            <span style=color:#6272a4># update genetic distance matrix</span>
</span></span><span style=display:flex><span>            distance_matrix <span style=color:#ff79c6>=</span> matrix
</span></span><span style=display:flex><span>            <span style=color:#6272a4># update current phylogenetic nodes needed to be merged</span>
</span></span><span style=display:flex><span>            leaf_set <span style=color:#ff79c6>-=</span> <span style=color:#8be9fd;font-style:italic>set</span>(qmin_info[<span style=color:#f1fa8c>&#34;combination&#34;</span>])
</span></span><span style=display:flex><span>            leaf_set<span style=color:#ff79c6>.</span>add(new_node)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> neighbor_joining(leaf_set, distance_matrix)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># begin to compute until two phylogenetic nodes left</span>
</span></span><span style=display:flex><span>    final_leaf_set, final_matrix <span style=color:#ff79c6>=</span> neighbor_joining(leaf_set, distance_matrix)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> TREEDICT, final_leaf_set, final_matrix
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#               PREORDER TREE AND ADD INDEX</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>my_tree</span>(TREEDICT: <span style=color:#8be9fd;font-style:italic>dict</span>, final_distance_matrix: <span style=color:#8be9fd;font-style:italic>dict</span>, seqs: <span style=color:#8be9fd;font-style:italic>dict</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;function to create Binary tree but it has fake root
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            because phylogenetic node has three children
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            hence create a fake node as root to get a Binary Tree
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            all following behaviors related Binary Tree usually consider this situation
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            for binary_tree.key:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>            key[0] -&gt; label ; key[1] -&gt; edge
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        TREEDICT ([dict]): [store information of binary tree ]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        final_distance_matrix ([dict]): [distance of final two nodes]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seqs ([dict]): [store information of seqs]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        [binary tree]: [binary tree with fake root]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># &#39;merged node&#39; means nodes have been changed as binary tree</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init value to find if node is &#39;merged node&#39;  in final two nodes after NJ</span>
</span></span><span style=display:flex><span>    last_node_label <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>    last_node_edges <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> index, value <span style=color:#ff79c6>in</span> final_distance_matrix<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># get edge</span>
</span></span><span style=display:flex><span>        last_node_edges <span style=color:#ff79c6>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># check if node is &#39;merged node&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> label <span style=color:#ff79c6>in</span> index:
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if not</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> label <span style=color:#ff79c6>in</span> seqs:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># get label</span>
</span></span><span style=display:flex><span>                last_node_label <span style=color:#ff79c6>=</span> label
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># create a fake root with label &#39;root&#39;</span>
</span></span><span style=display:flex><span>    fake_root <span style=color:#ff79c6>=</span> TreeNode((<span style=color:#f1fa8c>&#34;root&#34;</span>, <span style=color:#f1fa8c>&#34; &#34;</span>))
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get node label of final two nodes after NJ</span>
</span></span><span style=display:flex><span>    current_node_index <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>list</span>(TREEDICT<span style=color:#ff79c6>.</span>keys())
</span></span><span style=display:flex><span>    <span style=color:#6272a4># if final two nodes are merged node</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> last_node_label:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># add last edge to right children of fake root</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># because the left children of fake root is &#34;TRUE root&#34;, which has three childerns</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># the right children of fake root is linked to left children of it in real</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># so the edge indicates the distance between left children and right children</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># even though right children is linked to fake root in binary_tree</span>
</span></span><span style=display:flex><span>        TREEDICT[current_node_index[<span style=color:#bd93f9>1</span>]]<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> last_node_edges
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># create tree structure</span>
</span></span><span style=display:flex><span>        fake_root<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>=</span> TREEDICT[current_node_index[<span style=color:#bd93f9>0</span>]]
</span></span><span style=display:flex><span>        fake_root<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> TREEDICT[current_node_index[<span style=color:#bd93f9>1</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># if one of final two nodes is merged node</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># set node that is not merged node as tree structure</span>
</span></span><span style=display:flex><span>        right_node <span style=color:#ff79c6>=</span> TreeNode([last_node_label, last_node_edges])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># set one of final two nodes, a merged node, as left children of fake root</span>
</span></span><span style=display:flex><span>        fake_root<span style=color:#ff79c6>.</span>left <span style=color:#ff79c6>=</span> TREEDICT[current_node_index[<span style=color:#bd93f9>0</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># add right children</span>
</span></span><span style=display:flex><span>        fake_root<span style=color:#ff79c6>.</span>right <span style=color:#ff79c6>=</span> right_node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fake_root
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>help_edge_matrix</span>(tree, seqs: <span style=color:#8be9fd;font-style:italic>dict</span>, edge_file: <span style=color:#8be9fd;font-style:italic>str</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[help function to do preorder traversal in order to get edge file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree ([Binary Tree])
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seqs (dict): [store information about label, seq, and index of seqs]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        edge_file (str): [output of edge]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        [Binary Tree]: [Binary Tree whose internal node has index]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init index for internal node</span>
</span></span><span style=display:flex><span>    N <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>len</span>(seqs) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># open new file</span>
</span></span><span style=display:flex><span>    EDGE_FILE <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(edge_file, <span style=color:#f1fa8c>&#34;w&#34;</span>)  <span style=color:#6272a4># changes</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>edge_matrix</span>(tree):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># get nonlocal value</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>nonlocal</span> N
</span></span><span style=display:flex><span>        <span style=color:#6272a4># preorder tree</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> tree:
</span></span><span style=display:flex><span>            <span style=color:#6272a4># index of fake root is None</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> tree<span style=color:#ff79c6>.</span>isRoot():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                tree<span style=color:#ff79c6>.</span>index <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>None</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># tree.key[0] is label of node</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if it not in seqs then it is internal node</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>elif</span> tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>in</span> seqs:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># set index for internal node</span>
</span></span><span style=display:flex><span>                tree<span style=color:#ff79c6>.</span>index <span style=color:#ff79c6>=</span> N
</span></span><span style=display:flex><span>                N <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># get index of leaf node</span>
</span></span><span style=display:flex><span>                tree<span style=color:#ff79c6>.</span>index <span style=color:#ff79c6>=</span> seqs[tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>]]<span style=color:#ff79c6>.</span>index
</span></span><span style=display:flex><span>            <span style=color:#6272a4># write information of parent and children</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># left and right children of fake root have no parent : None</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> tree<span style=color:#ff79c6>.</span>parent:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                EDGE_FILE<span style=color:#ff79c6>.</span>write(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>parent<span style=color:#ff79c6>.</span>index<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>index<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>            edge_matrix(tree<span style=color:#ff79c6>.</span>left)
</span></span><span style=display:flex><span>            edge_matrix(tree<span style=color:#ff79c6>.</span>right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    edge_matrix(tree)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># add the TRUE ROOT and its children</span>
</span></span><span style=display:flex><span>    EDGE_FILE<span style=color:#ff79c6>.</span>write(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>left<span style=color:#ff79c6>.</span>index<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>right<span style=color:#ff79c6>.</span>index<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\t</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>right<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    EDGE_FILE<span style=color:#ff79c6>.</span>close()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> tree
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#                         POSTORDER TREE</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># WARNING: MUST CONDUCT AFTER PREODER</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>help_newick_parse</span>(tree, tree_file: <span style=color:#8be9fd;font-style:italic>str</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[help function to do postorder traversal in order to get tree file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree ([Binary Tree])
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree_file (str): [output of tree]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># open tree file</span>
</span></span><span style=display:flex><span>    TREE_FILE <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>open</span>(tree_file, <span style=color:#f1fa8c>&#34;w&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get true root label (left children of fake root)</span>
</span></span><span style=display:flex><span>    true_root_label <span style=color:#ff79c6>=</span> tree<span style=color:#ff79c6>.</span>left<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>newick_parse</span>(tree):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># get nonlocal value</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>nonlocal</span> true_root_label
</span></span><span style=display:flex><span>        <span style=color:#6272a4># postorder tree</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> tree:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> newick_parse(tree<span style=color:#ff79c6>.</span>left)
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> newick_parse(tree<span style=color:#ff79c6>.</span>right)
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if node is internal node</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> left <span style=color:#ff79c6>and</span> right:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># check if node is true node</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> true_root_label:
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># not add &#39;( )&#39; so as to have three children finally</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>left<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>,</span><span style=color:#f1fa8c>{</span>right<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4># check if node is root</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>elif</span> tree<span style=color:#ff79c6>.</span>isRoot():
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># add &#39;()&#39; finally</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;(</span><span style=color:#f1fa8c>{</span>left<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>,</span><span style=color:#f1fa8c>{</span>right<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>)&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4># if node is internal node</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;(</span><span style=color:#f1fa8c>{</span>left<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>,</span><span style=color:#f1fa8c>{</span>right<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>):</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># if node is leaf node</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>0</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>{</span>tree<span style=color:#ff79c6>.</span>key[<span style=color:#bd93f9>1</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newick <span style=color:#ff79c6>=</span> newick_parse(tree)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TREE_FILE<span style=color:#ff79c6>.</span>write(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>newick<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TREE_FILE<span style=color:#ff79c6>.</span>close()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#                         BOOTSTRAP</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>bootstrap</span>(original_seqs: <span style=color:#8be9fd;font-style:italic>dict</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;bootstrap original seqs and return bootstrap sample and bootstrap seqs
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        original_seqs (dict): original seqs
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree_root_with_node_index: bootstrap sample whose node has index
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seqs_bootstrap : bootstrap seqs contained information like index, label, and sequences
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># change data structure in order to use pandas:</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#               0 1 2  (column_number)</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># label 1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># label 2</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># ...</span>
</span></span><span style=display:flex><span>    seqs_pd <span style=color:#ff79c6>=</span> {index: <span style=color:#8be9fd;font-style:italic>list</span>(value<span style=color:#ff79c6>.</span>seq) <span style=color:#ff79c6>for</span> index, value <span style=color:#ff79c6>in</span> original_seqs<span style=color:#ff79c6>.</span>items()}
</span></span><span style=display:flex><span>    df <span style=color:#ff79c6>=</span> pd<span style=color:#ff79c6>.</span>DataFrame(seqs_pd)<span style=color:#ff79c6>.</span>T
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># using random to resample</span>
</span></span><span style=display:flex><span>    df_bootstrap <span style=color:#ff79c6>=</span> df<span style=color:#ff79c6>.</span>loc[:, random<span style=color:#ff79c6>.</span>choices(<span style=color:#8be9fd;font-style:italic>range</span>(df<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>1</span>]), k<span style=color:#ff79c6>=</span>df<span style=color:#ff79c6>.</span>shape[<span style=color:#bd93f9>1</span>])]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get bootstrap information</span>
</span></span><span style=display:flex><span>    seqs_bootstrap <span style=color:#ff79c6>=</span> original_seqs<span style=color:#ff79c6>.</span>copy()
</span></span><span style=display:flex><span>    <span style=color:#6272a4># change sequences to bootstrap sequences</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> index, value <span style=color:#ff79c6>in</span> df_bootstrap<span style=color:#ff79c6>.</span>iterrows():
</span></span><span style=display:flex><span>        seqs_bootstrap[index] <span style=color:#ff79c6>=</span> seqs_bootstrap[index]<span style=color:#ff79c6>.</span>_replace(
</span></span><span style=display:flex><span>            seq<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;&#34;</span><span style=color:#ff79c6>.</span>join(value<span style=color:#ff79c6>.</span>values)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get nodes needed to be coudcted NJ</span>
</span></span><span style=display:flex><span>    leaf_set <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>set</span>(seqs_bootstrap<span style=color:#ff79c6>.</span>keys())
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate genetic_distance for bootstrap samples</span>
</span></span><span style=display:flex><span>    distance_map <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> seq1_label, seq1_info <span style=color:#ff79c6>in</span> seqs_bootstrap<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> seq2_label, seq2_info <span style=color:#ff79c6>in</span> seqs_bootstrap<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> seq1_label <span style=color:#ff79c6>!=</span> seq2_label:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                distance <span style=color:#ff79c6>=</span> fetch_distance(seq1_label, seq2_label, distance_map)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> distance:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    distance <span style=color:#ff79c6>=</span> genetic_distance(seq1_info<span style=color:#ff79c6>.</span>seq, seq2_info<span style=color:#ff79c6>.</span>seq)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    distance_map[(seq1_label, seq2_label)] <span style=color:#ff79c6>=</span> distance
</span></span><span style=display:flex><span>    <span style=color:#6272a4># conduct NJ</span>
</span></span><span style=display:flex><span>    TREEDICT, _, final_distance_matrix <span style=color:#ff79c6>=</span> help_nj(leaf_set, distance_map)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># construct binary_tree</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get edge file for  last bootstrap (NOT USED)</span>
</span></span><span style=display:flex><span>    tree_root <span style=color:#ff79c6>=</span> my_tree(TREEDICT, final_distance_matrix, seqs_bootstrap)
</span></span><span style=display:flex><span>    tree_root_with_node_index <span style=color:#ff79c6>=</span> help_edge_matrix(
</span></span><span style=display:flex><span>        tree_root, seqs_bootstrap, <span style=color:#f1fa8c>&#34;last_bootstrap.edge&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> tree_root_with_node_index, seqs_bootstrap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>help_find_partion</span>(tree) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;function to partition list for internal nodes in a binary tree
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree (binary_tree): [binary_tree with fake root
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        dict: node_index: partition list
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init dict to store index and its partition list</span>
</span></span><span style=display:flex><span>    internal_node_partion <span style=color:#ff79c6>=</span> defaultdict(<span style=color:#8be9fd;font-style:italic>list</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># postorder traversal to find leafs for every internal node</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>find_partion</span>(tree):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        LIST <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#6272a4># begin</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> tree:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> find_partion(tree<span style=color:#ff79c6>.</span>left)
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> find_partion(tree<span style=color:#ff79c6>.</span>right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> tree<span style=color:#ff79c6>.</span>isLeaf():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                LIST<span style=color:#ff79c6>.</span>append(tree<span style=color:#ff79c6>.</span>index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># flatten list</span>
</span></span><span style=display:flex><span>                LIST<span style=color:#ff79c6>.</span>extend([<span style=color:#ff79c6>*</span>left, <span style=color:#ff79c6>*</span>right])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                internal_node_partion[tree<span style=color:#ff79c6>.</span>index]<span style=color:#ff79c6>.</span>extend(<span style=color:#8be9fd;font-style:italic>sorted</span>([<span style=color:#ff79c6>*</span>left, <span style=color:#ff79c6>*</span>right]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> LIST
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># change partition list of fake root to true root</span>
</span></span><span style=display:flex><span>    find_partion(tree)
</span></span><span style=display:flex><span>    internal_node_partion[tree<span style=color:#ff79c6>.</span>left<span style=color:#ff79c6>.</span>index] <span style=color:#ff79c6>=</span> internal_node_partion<span style=color:#ff79c6>.</span>pop(tree<span style=color:#ff79c6>.</span>index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> internal_node_partion
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>get_bootstrap_value</span>(
</span></span><span style=display:flex><span>    bootstrap_number: <span style=color:#8be9fd;font-style:italic>int</span>,
</span></span><span style=display:flex><span>    original_seqs: <span style=color:#8be9fd;font-style:italic>dict</span>,
</span></span><span style=display:flex><span>    original_tree,
</span></span><span style=display:flex><span>    bootstrap_file: <span style=color:#8be9fd;font-style:italic>str</span> <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;bootstrap.txt&#34;</span>,
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[function to integrate relation methods to get bootstrap values for original tree]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        bootstrap_number (int): [number for bootstrap. default = None]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        original_seqs (dict): [information of original sequences]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        original_tree ([type]): [binary tree of original sequences]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        bootstrap_file (str): [output of bootstrap]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init list to store bootstrap value for every internal node</span>
</span></span><span style=display:flex><span>    internal_node_bootstrap_value <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>*</span> (<span style=color:#8be9fd;font-style:italic>len</span>(original_seqs) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get partition list of every internal node in original tree</span>
</span></span><span style=display:flex><span>    original_partion_dict <span style=color:#ff79c6>=</span> help_find_partion(original_tree)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># init list to store dict contained bootstrap_partion and its node_index</span>
</span></span><span style=display:flex><span>    bootstrap_partion_list <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#6272a4># begin to bootstrap and consruct binary tree</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> number <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(bootstrap_number):
</span></span><span style=display:flex><span>        logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;BOOTSTRAP NUMBER : </span><span style=color:#f1fa8c>{</span>number<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>        bootstrap_tree, _ <span style=color:#ff79c6>=</span> bootstrap(original_seqs)
</span></span><span style=display:flex><span>        bootstrap_partion_list<span style=color:#ff79c6>.</span>append(help_find_partion(bootstrap_tree))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># compare partition list to update bootstrap value</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> internal_node_index, partion_conent <span style=color:#ff79c6>in</span> original_partion_dict<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> bootstrap_partion <span style=color:#ff79c6>in</span> bootstrap_partion_list:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> partion_conent <span style=color:#ff79c6>in</span> bootstrap_partion<span style=color:#ff79c6>.</span>values():
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                internal_node_bootstrap_value[
</span></span><span style=display:flex><span>                    internal_node_index <span style=color:#ff79c6>-</span> <span style=color:#8be9fd;font-style:italic>len</span>(original_seqs) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>                ] <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># change format for the bootstrap values</span>
</span></span><span style=display:flex><span>    result <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>value<span style=color:#ff79c6>/</span>bootstrap_number<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span> <span style=color:#ff79c6>for</span> value <span style=color:#ff79c6>in</span> internal_node_bootstrap_value]
</span></span><span style=display:flex><span>    <span style=color:#6272a4># write to file</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> <span style=color:#8be9fd;font-style:italic>open</span>(bootstrap_file, <span style=color:#f1fa8c>&#34;w&#34;</span>) <span style=color:#ff79c6>as</span> file:
</span></span><span style=display:flex><span>        file<span style=color:#ff79c6>.</span>writelines(result)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#                                  MAIN</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>##############################################</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>worker</span>(args: <span style=color:#8be9fd;font-style:italic>dict</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;[function to integrate all above method to conduct NJ and output tree and edge file]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Args:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        args ([dict]): [parameters getting from command line]
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        tree_root_with_index : binary tree whose node has index
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>        seq : information of sequences
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># read fa file and parse it</span>
</span></span><span style=display:flex><span>    seqs <span style=color:#ff79c6>=</span> read_input(args<span style=color:#ff79c6>.</span>input)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get labels of sequences</span>
</span></span><span style=display:flex><span>    leaf_set <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>set</span>(seqs<span style=color:#ff79c6>.</span>keys())
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get pair genetic distance</span>
</span></span><span style=display:flex><span>    distance_matrix <span style=color:#ff79c6>=</span> get_distance_matrix(seqs, args<span style=color:#ff79c6>.</span>distance)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># delete distances between same sequences</span>
</span></span><span style=display:flex><span>    distance_matrix <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        item: value <span style=color:#ff79c6>for</span> item, value <span style=color:#ff79c6>in</span> distance_matrix<span style=color:#ff79c6>.</span>items() <span style=color:#ff79c6>if</span> value <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get TREEDICT and distance of final two nodes</span>
</span></span><span style=display:flex><span>    TREEDICT, _, final_distance_matrix <span style=color:#ff79c6>=</span> help_nj(leaf_set, distance_matrix)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># construct binary tree REMEMBER it has fake root</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># left children of fake root is regarded as true root</span>
</span></span><span style=display:flex><span>    tree_root <span style=color:#ff79c6>=</span> my_tree(TREEDICT, final_distance_matrix, seqs)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get edge file and add index for every node in binary tree</span>
</span></span><span style=display:flex><span>    tree_root_with_index <span style=color:#ff79c6>=</span> help_edge_matrix(tree_root, seqs, args<span style=color:#ff79c6>.</span>edge)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get tree file REMEMBER it must conduct after getting edge files</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># because it need index of node</span>
</span></span><span style=display:flex><span>    help_newick_parse(tree_root_with_index, args<span style=color:#ff79c6>.</span>tree)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> tree_root_with_index, seqs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>main</span>():
</span></span><span style=display:flex><span>    args <span style=color:#ff79c6>=</span> get_parser()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>with</span> Timer() <span style=color:#ff79c6>as</span> t:
</span></span><span style=display:flex><span>        logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;Neighbor Joining begin.......&#34;</span>)
</span></span><span style=display:flex><span>        tree_root_with_index, seqs <span style=color:#ff79c6>=</span> worker(args)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;Neighbor Joining  DONE : TIME </span><span style=color:#f1fa8c>{</span>t<span style=color:#ff79c6>.</span>elapsed<span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>.2f</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>s</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> args<span style=color:#ff79c6>.</span>bootstrap:
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>with</span> Timer() <span style=color:#ff79c6>as</span> t:
</span></span><span style=display:flex><span>            get_bootstrap_value(args<span style=color:#ff79c6>.</span>bootstrap, seqs, tree_root_with_index)
</span></span><span style=display:flex><span>        logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;BOOTSTRAP IS DONE : TIME </span><span style=color:#f1fa8c>{</span>t<span style=color:#ff79c6>.</span>elapsed<span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>.2f</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>s</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;BOOTSTRAP IS NOT DONE&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;EDGE_FILE : </span><span style=color:#f1fa8c>{</span>args<span style=color:#ff79c6>.</span>edge<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>    logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;TREE_FILE :  </span><span style=color:#f1fa8c>{</span>args<span style=color:#ff79c6>.</span>tree<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>    logging<span style=color:#ff79c6>.</span>info(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;DISTANCE_FILE: </span><span style=color:#f1fa8c>{</span>args<span style=color:#ff79c6>.</span>distance<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> __name__ <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p><strong>Thanks for your reading! Hopefully helpful!</strong></p></div></article><hr><p class=articleTagsContainer><span></span>
<strong>Tags:</strong>
<a href=/tags/bioinformatics>#Bioinformatics</a></p><script type=text/javascript src=https://latest.cactus.chat/cactus.js></script><div id=ficurinia-cactus-comments></div><script>initComments({node:document.getElementById("ficurinia-cactus-comments"),defaultHomeserverUrl:"https://matrix.cactus.chat:8448",serverName:"cactus.chat",siteName:"blog",commentSectionId:"f8b3f9a631d032dfd1549fa0cf6ef9c1"})</script><div class=relatedArticlesContainer><hr><h2>More posts like this</h2><div class=postlist><article class="card postlistitem"><div><h2><a href=https://yangyangli.top/posts/011-bioinformatics-algorithm-library/>Bioinformatics Algorithm Library aka BINARY</a></h2><p class=date><span title=Date></span>
2022-09-26
|
<span title=Tags></span>
<a href=/tags/algorithms>#Algorithms</a>
<a href=/tags/bioinformatics>#Bioinformatics</a>
<a href=/tags/c++>#C++</a>
<a href=/tags/data-structures>#Data Structures</a></p><div class=articlePreview><p>A collection of algorithms and data structures that are designed for modern C++ bioinformatics applications.</p><p><a href=https://yangyangli.top/posts/011-bioinformatics-algorithm-library/>Continue reading </a></p></div></div><hr></article><article class="card postlistitem"><div><h2><a href=https://yangyangli.top/posts/009-new-tool-bioinformatics-toolbox-aka-boss/>Bioinformatics Toolbox Aka Boss</a></h2><p class=date><span title=Date></span>
2022-09-25
|
<span title=Tags></span>
<a href=/tags/bioinformatics>#Bioinformatics</a>
<a href=/tags/c++>#C++</a>
<a href=/tags/develop>#Develop</a></p><div class=articlePreview><p>A toolbox for bioinformatics analysis in C++</p><p><a href=https://yangyangli.top/posts/009-new-tool-bioinformatics-toolbox-aka-boss/>Continue reading </a></p></div></div><hr></article></div></div></main><footer><hr><p><small>2022 &copy; Yangyang Li - <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>.</small></p><p><small><a href=https://gitlab.com/gabmus/hugo-ficurinia>Ficurinia theme</a> for <a href=https://gohugo.io>Hugo</a> by <a href=https://gabmus.org>Gabriele Musco</a>. Licensed under <a href=https://www.gnu.org/licenses/agpl-3.0.html>GNU AGPLv3</a>.</small></p></footer></div></div></div><script async defer data-domain=example.com src=https://something.com/...></script>
<script async defer data-website-id=example-tracking-code src=https://something.com/...></script></body></html>